"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/dashboard/charts/page",{

/***/ "(app-pages-browser)/./lib/indicators.ts":
/*!***************************!*\
  !*** ./lib/indicators.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateDeMarkPivots: () => (/* binding */ calculateDeMarkPivots),\n/* harmony export */   calculateEMA: () => (/* binding */ calculateEMA),\n/* harmony export */   calculateEMACloud: () => (/* binding */ calculateEMACloud),\n/* harmony export */   calculatePivots: () => (/* binding */ calculatePivots),\n/* harmony export */   calculateTimeBasedPivots: () => (/* binding */ calculateTimeBasedPivots),\n/* harmony export */   getTrendStatus: () => (/* binding */ getTrendStatus)\n/* harmony export */ });\nfunction calculateDeMarkPivots(prices) {\n    if (!prices || prices.length === 0) {\n        return {\n            x: 0,\n            r1: 0,\n            pp: 0,\n            s1: 0\n        };\n    }\n    const price = prices[0];\n    const close = price.close;\n    const high = price.high;\n    const low = price.low;\n    // Calculate X based on DeMark's conditions\n    let x;\n    if (close < price.open) {\n        x = high + 2 * low + close;\n    } else if (close > price.open) {\n        x = 2 * high + low + close;\n    } else {\n        x = high + low + 2 * close;\n    }\n    // Calculate pivot points\n    const pp = x / 4;\n    const r1 = x / 2 - low;\n    const s1 = x / 2 - high;\n    return {\n        x: Number(x.toFixed(2)),\n        r1: Number(r1.toFixed(2)),\n        pp: Number(pp.toFixed(2)),\n        s1: Number(s1.toFixed(2))\n    };\n}\nfunction calculateEMA(prices, period) {\n    if (!prices.length || period <= 0) return [];\n    // Calculate SMA for initial EMA value\n    let sma = 0;\n    for(let i = 0; i < period && i < prices.length; i++){\n        sma += prices[i];\n    }\n    sma = sma / period;\n    const k = 2 / (period + 1);\n    const emaData = [];\n    let ema = sma;\n    // Fill initial values with SMA\n    for(let i = 0; i < period - 1 && i < prices.length; i++){\n        emaData.push(sma);\n    }\n    // Calculate EMA values\n    for(let i = period - 1; i < prices.length; i++){\n        ema = prices[i] * k + ema * (1 - k);\n        emaData.push(Number(ema.toFixed(2)));\n    }\n    return emaData;\n}\nfunction calculateEMACloud(prices, fastPeriod, slowPeriod) {\n    // Sort prices chronologically\n    const sortedPrices = [\n        ...prices\n    ].sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n    const closePrices = sortedPrices.map((p)=>p.close);\n    const dates = sortedPrices.map((p)=>p.date);\n    const fastEMA = calculateEMA(closePrices, fastPeriod);\n    const slowEMA = calculateEMA(closePrices, slowPeriod);\n    // Find crossovers\n    const crossovers = [];\n    for(let i = 1; i < prices.length; i++){\n        const prevFast = fastEMA[i - 1];\n        const prevSlow = slowEMA[i - 1];\n        const currFast = fastEMA[i];\n        const currSlow = slowEMA[i];\n        if (prevFast <= prevSlow && currFast > currSlow) {\n            crossovers.push({\n                date: dates[i],\n                type: 'bullish'\n            });\n        } else if (prevFast >= prevSlow && currFast < currSlow) {\n            crossovers.push({\n                date: dates[i],\n                type: 'bearish'\n            });\n        }\n    }\n    return {\n        fast: fastEMA,\n        slow: slowEMA,\n        dates,\n        crossovers\n    };\n}\nfunction calculateTimeBasedPivots(prices, timeframe) {\n    let pivotType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'standard';\n    if (!prices || prices.length === 0) {\n        return {\n            r3: 0,\n            r2: 0,\n            r1: 0,\n            pp: 0,\n            s1: 0,\n            s2: 0,\n            s3: 0\n        };\n    }\n    // Bestimme den relevanten Datensatz basierend auf dem Timeframe\n    let relevantPrices = prices;\n    if (timeframe === 'weekly' && prices.length >= 5) {\n        relevantPrices = prices.slice(-5);\n    } else if (timeframe === 'monthly' && prices.length >= 20) {\n        relevantPrices = prices.slice(-20);\n    } else if (timeframe === 'quarterly' && prices.length >= 60) {\n        relevantPrices = prices.slice(-60);\n    } else if (timeframe === 'yearly' && prices.length >= 250) {\n        relevantPrices = prices.slice(-250);\n    }\n    if (!relevantPrices || relevantPrices.length === 0) {\n        return {\n            r3: 0,\n            r2: 0,\n            r1: 0,\n            pp: 0,\n            s1: 0,\n            s2: 0,\n            s3: 0\n        };\n    }\n    // Calculate period high and low\n    let periodHigh = relevantPrices[0].high;\n    let periodLow = relevantPrices[0].low;\n    let periodClose = relevantPrices[0].close;\n    // For timeframes longer than daily, find the period's high and low\n    if (timeframe !== 'daily' && relevantPrices.length > 1) {\n        periodHigh = Math.max(...relevantPrices.map((p)=>p.high));\n        periodLow = Math.min(...relevantPrices.map((p)=>p.low));\n        // Use the most recent close for the period\n        periodClose = relevantPrices[0].close;\n    }\n    // Standard Floor Trader's Method\n    const pp = (periodHigh + periodLow + periodClose) / 3;\n    if (pivotType === 'standard') {\n        // Standard Pivot Points\n        const r1 = 2 * pp - periodLow;\n        const s1 = 2 * pp - periodHigh;\n        const r2 = pp + (periodHigh - periodLow);\n        const s2 = pp - (periodHigh - periodLow);\n        const r3 = periodHigh + 2 * (pp - periodLow);\n        const s3 = periodLow - 2 * (periodHigh - pp);\n        return {\n            r3: Number(r3.toFixed(2)),\n            r2: Number(r2.toFixed(2)),\n            r1: Number(r1.toFixed(2)),\n            pp: Number(pp.toFixed(2)),\n            s1: Number(s1.toFixed(2)),\n            s2: Number(s2.toFixed(2)),\n            s3: Number(s3.toFixed(2))\n        };\n    } else if (pivotType === 'demark') {\n        // DeMark Pivot Points\n        let x = 0;\n        // Use the first price in the relevant prices for open price\n        const periodOpen = relevantPrices[0].open;\n        if (periodClose < periodOpen) {\n            x = periodHigh + 2 * periodLow + periodClose;\n        } else if (periodClose > periodOpen) {\n            x = 2 * periodHigh + periodLow + periodClose;\n        } else {\n            x = periodHigh + periodLow + 2 * periodClose;\n        }\n        const demarkPP = x / 4;\n        const r1 = x / 2 - periodLow;\n        const s1 = x / 2 - periodHigh;\n        return {\n            x: Number(x.toFixed(2)),\n            r1: Number(r1.toFixed(2)),\n            pp: Number(demarkPP.toFixed(2)),\n            s1: Number(s1.toFixed(2))\n        };\n    }\n    // Default return for type safety\n    return {\n        r3: 0,\n        r2: 0,\n        r1: 0,\n        pp: 0,\n        s1: 0,\n        s2: 0,\n        s3: 0\n    };\n}\n// Legacy-Funktion für Kompatibilität\nfunction calculatePivots(prices) {\n    const levels = calculateTimeBasedPivots(prices, 'daily');\n    return levels;\n}\nfunction getTrendStatus(cloud5_12, cloud34_50) {\n    const latest5_12 = {\n        fast: cloud5_12.fast[cloud5_12.fast.length - 1],\n        slow: cloud5_12.slow[cloud5_12.slow.length - 1]\n    };\n    const latest34_50 = {\n        fast: cloud34_50.fast[cloud34_50.fast.length - 1],\n        slow: cloud34_50.slow[cloud34_50.slow.length - 1]\n    };\n    // Get the latest prices and indicators\n    const prices = cloud5_12.fast;\n    const latestPrice = prices[prices.length - 1];\n    const previousPrice = prices[prices.length - 2];\n    // Primary Trend based on 34-50 zone\n    const aboveLongTermZone = latestPrice > latest34_50.slow;\n    const belowLongTermZone = latestPrice < latest34_50.slow;\n    // Short-term confirmation using 5-12 zone\n    const shortTermBullish = latest5_12.fast > latest5_12.slow;\n    const shortTermBearish = latest5_12.fast < latest5_12.slow;\n    // Intraday Trend\n    let intradayTrend = 'neutral';\n    if (shortTermBullish && latestPrice > previousPrice) {\n        intradayTrend = 'bullish';\n    } else if (shortTermBearish && latestPrice < previousPrice) {\n        intradayTrend = 'bearish';\n    }\n    // Swing Trend\n    let swingTrend = 'neutral';\n    if (aboveLongTermZone) {\n        swingTrend = 'bullish';\n    } else if (belowLongTermZone) {\n        swingTrend = 'bearish';\n    }\n    // Position Trend (Overall)\n    let positionTrend = 'neutral';\n    if (aboveLongTermZone && shortTermBullish) {\n        positionTrend = 'bullish';\n    } else if (belowLongTermZone && shortTermBearish) {\n        positionTrend = 'bearish';\n    }\n    // Calculate trend strength based on distance from zone boundaries\n    const shortTermStrength = Math.abs((latestPrice - latest5_12.slow) / latest5_12.slow * 100);\n    const longTermStrength = Math.abs((latestPrice - latest34_50.slow) / latest34_50.slow * 100);\n    const strength = Math.min(100, Math.round((shortTermStrength + longTermStrength) * 2));\n    return {\n        intradayTrend,\n        swingTrend,\n        positionTrend,\n        strength\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBQ3hELE1BQU00QixvQkFBb0JILGNBQWNELFlBQVl4QixJQUFJO0lBRXhELDBDQUEwQztJQUMxQyxNQUFNNkIsbUJBQW1CTixXQUFXeEIsSUFBSSxHQUFHd0IsV0FBV3ZCLElBQUk7SUFDMUQsTUFBTThCLG1CQUFtQlAsV0FBV3hCLElBQUksR0FBR3dCLFdBQVd2QixJQUFJO0lBRTFELGlCQUFpQjtJQUNqQixJQUFJK0IsZ0JBQW1EO0lBQ3ZELElBQUlGLG9CQUFvQkosY0FBY0MsZUFBZTtRQUNuREssZ0JBQWdCO0lBQ2xCLE9BQU8sSUFBSUQsb0JBQW9CTCxjQUFjQyxlQUFlO1FBQzFESyxnQkFBZ0I7SUFDbEI7SUFFQSxjQUFjO0lBQ2QsSUFBSUMsYUFBZ0Q7SUFDcEQsSUFBSUwsbUJBQW1CO1FBQ3JCSyxhQUFhO0lBQ2YsT0FBTyxJQUFJSixtQkFBbUI7UUFDNUJJLGFBQWE7SUFDZjtJQUVBLDJCQUEyQjtJQUMzQixJQUFJQyxnQkFBbUQ7SUFDdkQsSUFBSU4scUJBQXFCRSxrQkFBa0I7UUFDekNJLGdCQUFnQjtJQUNsQixPQUFPLElBQUlMLHFCQUFxQkUsa0JBQWtCO1FBQ2hERyxnQkFBZ0I7SUFDbEI7SUFFQSxrRUFBa0U7SUFDbEUsTUFBTUMsb0JBQW9CckIsS0FBS3NCLEdBQUcsQ0FBQyxDQUFDVixjQUFjRixXQUFXdkIsSUFBSSxJQUFJdUIsV0FBV3ZCLElBQUksR0FBRztJQUN2RixNQUFNb0MsbUJBQW1CdkIsS0FBS3NCLEdBQUcsQ0FBQyxDQUFDVixjQUFjRCxZQUFZeEIsSUFBSSxJQUFJd0IsWUFBWXhCLElBQUksR0FBRztJQUV4RixNQUFNcUMsV0FBV3hCLEtBQUtFLEdBQUcsQ0FBQyxLQUFLRixLQUFLeUIsS0FBSyxDQUFDLENBQUNKLG9CQUFvQkUsZ0JBQWUsSUFBSztJQUVuRixPQUFPO1FBQ0xMO1FBQ0FDO1FBQ0FDO1FBQ0FJO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3N0ZWZmZW5nb3R0bGUvRGVza3RvcC9uZXh0bGV2ZWx0cmFkZXJzL2xpYi9pbmRpY2F0b3JzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgSGlzdG9yaWNhbFByaWNlIH0gZnJvbSAnLi9mbXAnO1xuXG5leHBvcnQgdHlwZSBQaXZvdFR5cGUgPSAnc3RhbmRhcmQnIHwgJ2RlbWFyayc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVNYXJrUGl2b3RMZXZlbHMge1xuICB4OiBudW1iZXI7XG4gIHIxOiBudW1iZXI7XG4gIHBwOiBudW1iZXI7XG4gIHMxOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhbmRhcmRQaXZvdExldmVscyB7XG4gIHIzOiBudW1iZXI7XG4gIHIyOiBudW1iZXI7XG4gIHIxOiBudW1iZXI7XG4gIHBwOiBudW1iZXI7XG4gIHMxOiBudW1iZXI7XG4gIHMyOiBudW1iZXI7XG4gIHMzOiBudW1iZXI7XG59XG5cblxuZXhwb3J0IHR5cGUgUGl2b3RMZXZlbHMgPSBTdGFuZGFyZFBpdm90TGV2ZWxzIHwgRGVNYXJrUGl2b3RMZXZlbHM7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVEZU1hcmtQaXZvdHMocHJpY2VzOiBIaXN0b3JpY2FsUHJpY2VbXSk6IERlTWFya1Bpdm90TGV2ZWxzIHtcbiAgaWYgKCFwcmljZXMgfHwgcHJpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7IHg6IDAsIHIxOiAwLCBwcDogMCwgczE6IDAgfTtcbiAgfVxuXG4gIGNvbnN0IHByaWNlID0gcHJpY2VzWzBdO1xuICBjb25zdCBjbG9zZSA9IHByaWNlLmNsb3NlO1xuICBjb25zdCBoaWdoID0gcHJpY2UuaGlnaDtcbiAgY29uc3QgbG93ID0gcHJpY2UubG93O1xuXG4gIC8vIENhbGN1bGF0ZSBYIGJhc2VkIG9uIERlTWFyaydzIGNvbmRpdGlvbnNcbiAgbGV0IHg7XG4gIGlmIChjbG9zZSA8IHByaWNlLm9wZW4pIHtcbiAgICB4ID0gaGlnaCArICgyICogbG93KSArIGNsb3NlO1xuICB9IGVsc2UgaWYgKGNsb3NlID4gcHJpY2Uub3Blbikge1xuICAgIHggPSAoMiAqIGhpZ2gpICsgbG93ICsgY2xvc2U7XG4gIH0gZWxzZSB7XG4gICAgeCA9IGhpZ2ggKyBsb3cgKyAoMiAqIGNsb3NlKTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBwaXZvdCBwb2ludHNcbiAgY29uc3QgcHAgPSB4IC8gNDtcbiAgY29uc3QgcjEgPSB4IC8gMiAtIGxvdztcbiAgY29uc3QgczEgPSB4IC8gMiAtIGhpZ2g7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBOdW1iZXIoeC50b0ZpeGVkKDIpKSxcbiAgICByMTogTnVtYmVyKHIxLnRvRml4ZWQoMikpLFxuICAgIHBwOiBOdW1iZXIocHAudG9GaXhlZCgyKSksXG4gICAgczE6IE51bWJlcihzMS50b0ZpeGVkKDIpKVxuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVNQUNsb3VkIHtcbiAgZmFzdDogbnVtYmVyW107XG4gIHNsb3c6IG51bWJlcltdO1xuICBkYXRlczogc3RyaW5nW107XG4gIGNyb3Nzb3ZlcnM6IHsgZGF0ZTogc3RyaW5nOyB0eXBlOiAnYnVsbGlzaCcgfCAnYmVhcmlzaCcgfVtdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRU1BKHByaWNlczogbnVtYmVyW10sIHBlcmlvZDogbnVtYmVyKTogbnVtYmVyW10ge1xuICBpZiAoIXByaWNlcy5sZW5ndGggfHwgcGVyaW9kIDw9IDApIHJldHVybiBbXTtcblxuICAvLyBDYWxjdWxhdGUgU01BIGZvciBpbml0aWFsIEVNQSB2YWx1ZVxuICBsZXQgc21hID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZXJpb2QgJiYgaSA8IHByaWNlcy5sZW5ndGg7IGkrKykge1xuICAgIHNtYSArPSBwcmljZXNbaV07XG4gIH1cbiAgc21hID0gc21hIC8gcGVyaW9kO1xuXG4gIGNvbnN0IGsgPSAyIC8gKHBlcmlvZCArIDEpO1xuICBjb25zdCBlbWFEYXRhOiBudW1iZXJbXSA9IFtdO1xuICBsZXQgZW1hID0gc21hO1xuXG4gIC8vIEZpbGwgaW5pdGlhbCB2YWx1ZXMgd2l0aCBTTUFcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZXJpb2QgLSAxICYmIGkgPCBwcmljZXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbWFEYXRhLnB1c2goc21hKTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBFTUEgdmFsdWVzXG4gIGZvciAobGV0IGkgPSBwZXJpb2QgLSAxOyBpIDwgcHJpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgZW1hID0gKHByaWNlc1tpXSAqIGspICsgKGVtYSAqICgxIC0gaykpO1xuICAgIGVtYURhdGEucHVzaChOdW1iZXIoZW1hLnRvRml4ZWQoMikpKTtcbiAgfVxuXG4gIHJldHVybiBlbWFEYXRhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRU1BQ2xvdWQoXG4gIHByaWNlczogSGlzdG9yaWNhbFByaWNlW10sXG4gIGZhc3RQZXJpb2Q6IG51bWJlcixcbiAgc2xvd1BlcmlvZDogbnVtYmVyXG4pOiBFTUFDbG91ZCB7XG4gIC8vIFNvcnQgcHJpY2VzIGNocm9ub2xvZ2ljYWxseVxuICBjb25zdCBzb3J0ZWRQcmljZXMgPSBbLi4ucHJpY2VzXS5zb3J0KChhLCBiKSA9PiBcbiAgICBuZXcgRGF0ZShhLmRhdGUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGIuZGF0ZSkuZ2V0VGltZSgpXG4gICk7XG4gIFxuICBjb25zdCBjbG9zZVByaWNlcyA9IHNvcnRlZFByaWNlcy5tYXAocCA9PiBwLmNsb3NlKTtcbiAgY29uc3QgZGF0ZXMgPSBzb3J0ZWRQcmljZXMubWFwKHAgPT4gcC5kYXRlKTtcbiAgXG4gIGNvbnN0IGZhc3RFTUEgPSBjYWxjdWxhdGVFTUEoY2xvc2VQcmljZXMsIGZhc3RQZXJpb2QpO1xuICBjb25zdCBzbG93RU1BID0gY2FsY3VsYXRlRU1BKGNsb3NlUHJpY2VzLCBzbG93UGVyaW9kKTtcbiAgXG4gIC8vIEZpbmQgY3Jvc3NvdmVyc1xuICBjb25zdCBjcm9zc292ZXJzOiB7IGRhdGU6IHN0cmluZzsgdHlwZTogJ2J1bGxpc2gnIHwgJ2JlYXJpc2gnIH1bXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHByaWNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByZXZGYXN0ID0gZmFzdEVNQVtpIC0gMV07XG4gICAgY29uc3QgcHJldlNsb3cgPSBzbG93RU1BW2kgLSAxXTtcbiAgICBjb25zdCBjdXJyRmFzdCA9IGZhc3RFTUFbaV07XG4gICAgY29uc3QgY3VyclNsb3cgPSBzbG93RU1BW2ldO1xuICAgIFxuICAgIGlmIChwcmV2RmFzdCA8PSBwcmV2U2xvdyAmJiBjdXJyRmFzdCA+IGN1cnJTbG93KSB7XG4gICAgICBjcm9zc292ZXJzLnB1c2goeyBkYXRlOiBkYXRlc1tpXSwgdHlwZTogJ2J1bGxpc2gnIH0pO1xuICAgIH0gZWxzZSBpZiAocHJldkZhc3QgPj0gcHJldlNsb3cgJiYgY3VyckZhc3QgPCBjdXJyU2xvdykge1xuICAgICAgY3Jvc3NvdmVycy5wdXNoKHsgZGF0ZTogZGF0ZXNbaV0sIHR5cGU6ICdiZWFyaXNoJyB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgZmFzdDogZmFzdEVNQSxcbiAgICBzbG93OiBzbG93RU1BLFxuICAgIGRhdGVzLFxuICAgIGNyb3Nzb3ZlcnNcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVRpbWVCYXNlZFBpdm90cyhcbiAgcHJpY2VzOiBIaXN0b3JpY2FsUHJpY2VbXSxcbiAgdGltZWZyYW1lOiAnZGFpbHknIHwgJ3dlZWtseScgfCAnbW9udGhseScgfCAncXVhcnRlcmx5JyB8ICd5ZWFybHknLFxuICBwaXZvdFR5cGU6IFBpdm90VHlwZSA9ICdzdGFuZGFyZCdcbik6IFBpdm90TGV2ZWxzIHtcbiAgaWYgKCFwcmljZXMgfHwgcHJpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7IHIzOiAwLCByMjogMCwgcjE6IDAsIHBwOiAwLCBzMTogMCwgczI6IDAsIHMzOiAwIH07XG4gIH1cblxuICAvLyBCZXN0aW1tZSBkZW4gcmVsZXZhbnRlbiBEYXRlbnNhdHogYmFzaWVyZW5kIGF1ZiBkZW0gVGltZWZyYW1lXG4gIGxldCByZWxldmFudFByaWNlcyA9IHByaWNlcztcbiAgaWYgKHRpbWVmcmFtZSA9PT0gJ3dlZWtseScgJiYgcHJpY2VzLmxlbmd0aCA+PSA1KSB7XG4gICAgcmVsZXZhbnRQcmljZXMgPSBwcmljZXMuc2xpY2UoLTUpO1xuICB9IGVsc2UgaWYgKHRpbWVmcmFtZSA9PT0gJ21vbnRobHknICYmIHByaWNlcy5sZW5ndGggPj0gMjApIHtcbiAgICByZWxldmFudFByaWNlcyA9IHByaWNlcy5zbGljZSgtMjApO1xuICB9IGVsc2UgaWYgKHRpbWVmcmFtZSA9PT0gJ3F1YXJ0ZXJseScgJiYgcHJpY2VzLmxlbmd0aCA+PSA2MCkge1xuICAgIHJlbGV2YW50UHJpY2VzID0gcHJpY2VzLnNsaWNlKC02MCk7XG4gIH0gZWxzZSBpZiAodGltZWZyYW1lID09PSAneWVhcmx5JyAmJiBwcmljZXMubGVuZ3RoID49IDI1MCkge1xuICAgIHJlbGV2YW50UHJpY2VzID0gcHJpY2VzLnNsaWNlKC0yNTApO1xuICB9XG5cbiAgaWYgKCFyZWxldmFudFByaWNlcyB8fCByZWxldmFudFByaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4geyByMzogMCwgcjI6IDAsIHIxOiAwLCBwcDogMCwgczE6IDAsIHMyOiAwLCBzMzogMCB9O1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHBlcmlvZCBoaWdoIGFuZCBsb3dcbiAgbGV0IHBlcmlvZEhpZ2ggPSByZWxldmFudFByaWNlc1swXS5oaWdoO1xuICBsZXQgcGVyaW9kTG93ID0gcmVsZXZhbnRQcmljZXNbMF0ubG93O1xuICBsZXQgcGVyaW9kQ2xvc2UgPSByZWxldmFudFByaWNlc1swXS5jbG9zZTtcblxuICAvLyBGb3IgdGltZWZyYW1lcyBsb25nZXIgdGhhbiBkYWlseSwgZmluZCB0aGUgcGVyaW9kJ3MgaGlnaCBhbmQgbG93XG4gIGlmICh0aW1lZnJhbWUgIT09ICdkYWlseScgJiYgcmVsZXZhbnRQcmljZXMubGVuZ3RoID4gMSkge1xuICAgIHBlcmlvZEhpZ2ggPSBNYXRoLm1heCguLi5yZWxldmFudFByaWNlcy5tYXAocCA9PiBwLmhpZ2gpKTtcbiAgICBwZXJpb2RMb3cgPSBNYXRoLm1pbiguLi5yZWxldmFudFByaWNlcy5tYXAocCA9PiBwLmxvdykpO1xuICAgIC8vIFVzZSB0aGUgbW9zdCByZWNlbnQgY2xvc2UgZm9yIHRoZSBwZXJpb2RcbiAgICBwZXJpb2RDbG9zZSA9IHJlbGV2YW50UHJpY2VzWzBdLmNsb3NlO1xuICB9XG5cbiAgLy8gU3RhbmRhcmQgRmxvb3IgVHJhZGVyJ3MgTWV0aG9kXG4gIGNvbnN0IHBwID0gKHBlcmlvZEhpZ2ggKyBwZXJpb2RMb3cgKyBwZXJpb2RDbG9zZSkgLyAzO1xuXG4gIGlmIChwaXZvdFR5cGUgPT09ICdzdGFuZGFyZCcpIHtcbiAgICAvLyBTdGFuZGFyZCBQaXZvdCBQb2ludHNcbiAgICBjb25zdCByMSA9ICgyICogcHApIC0gcGVyaW9kTG93O1xuICAgIGNvbnN0IHMxID0gKDIgKiBwcCkgLSBwZXJpb2RIaWdoO1xuICAgIGNvbnN0IHIyID0gcHAgKyAocGVyaW9kSGlnaCAtIHBlcmlvZExvdyk7XG4gICAgY29uc3QgczIgPSBwcCAtIChwZXJpb2RIaWdoIC0gcGVyaW9kTG93KTtcbiAgICBjb25zdCByMyA9IHBlcmlvZEhpZ2ggKyAyICogKHBwIC0gcGVyaW9kTG93KTtcbiAgICBjb25zdCBzMyA9IHBlcmlvZExvdyAtIDIgKiAocGVyaW9kSGlnaCAtIHBwKTtcblxuICAgIHJldHVybiB7XG4gICAgICByMzogTnVtYmVyKHIzLnRvRml4ZWQoMikpLFxuICAgICAgcjI6IE51bWJlcihyMi50b0ZpeGVkKDIpKSxcbiAgICAgIHIxOiBOdW1iZXIocjEudG9GaXhlZCgyKSksXG4gICAgICBwcDogTnVtYmVyKHBwLnRvRml4ZWQoMikpLFxuICAgICAgczE6IE51bWJlcihzMS50b0ZpeGVkKDIpKSxcbiAgICAgIHMyOiBOdW1iZXIoczIudG9GaXhlZCgyKSksXG4gICAgICBzMzogTnVtYmVyKHMzLnRvRml4ZWQoMikpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChwaXZvdFR5cGUgPT09ICdkZW1hcmsnKSB7XG4gICAgLy8gRGVNYXJrIFBpdm90IFBvaW50c1xuICAgIGxldCB4ID0gMDtcbiAgICAvLyBVc2UgdGhlIGZpcnN0IHByaWNlIGluIHRoZSByZWxldmFudCBwcmljZXMgZm9yIG9wZW4gcHJpY2VcbiAgICBjb25zdCBwZXJpb2RPcGVuID0gcmVsZXZhbnRQcmljZXNbMF0ub3BlbjtcbiAgICBpZiAocGVyaW9kQ2xvc2UgPCBwZXJpb2RPcGVuKSB7XG4gICAgICB4ID0gcGVyaW9kSGlnaCArICgyICogcGVyaW9kTG93KSArIHBlcmlvZENsb3NlO1xuICAgIH0gZWxzZSBpZiAocGVyaW9kQ2xvc2UgPiBwZXJpb2RPcGVuKSB7XG4gICAgICB4ID0gKDIgKiBwZXJpb2RIaWdoKSArIHBlcmlvZExvdyArIHBlcmlvZENsb3NlO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gcGVyaW9kSGlnaCArIHBlcmlvZExvdyArICgyICogcGVyaW9kQ2xvc2UpO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBkZW1hcmtQUCA9IHggLyA0O1xuICAgIGNvbnN0IHIxID0geCAvIDIgLSBwZXJpb2RMb3c7XG4gICAgY29uc3QgczEgPSB4IC8gMiAtIHBlcmlvZEhpZ2g7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE51bWJlcih4LnRvRml4ZWQoMikpLFxuICAgICAgcjE6IE51bWJlcihyMS50b0ZpeGVkKDIpKSxcbiAgICAgIHBwOiBOdW1iZXIoZGVtYXJrUFAudG9GaXhlZCgyKSksXG4gICAgICBzMTogTnVtYmVyKHMxLnRvRml4ZWQoMikpXG4gICAgfSBhcyBEZU1hcmtQaXZvdExldmVscztcbiAgfVxuICBcbiAgLy8gRGVmYXVsdCByZXR1cm4gZm9yIHR5cGUgc2FmZXR5XG4gIHJldHVybiB7IHIzOiAwLCByMjogMCwgcjE6IDAsIHBwOiAwLCBzMTogMCwgczI6IDAsIHMzOiAwIH07XG59XG5cbi8vIExlZ2FjeS1GdW5rdGlvbiBmw7xyIEtvbXBhdGliaWxpdMOkdFxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVBpdm90cyhwcmljZXM6IEhpc3RvcmljYWxQcmljZVtdKTogUGl2b3RMZXZlbHMge1xuICBjb25zdCBsZXZlbHMgPSBjYWxjdWxhdGVUaW1lQmFzZWRQaXZvdHMocHJpY2VzLCAnZGFpbHknKTtcbiAgcmV0dXJuIGxldmVscztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyZW5kU3RhdHVzKGNsb3VkNV8xMjogRU1BQ2xvdWQsIGNsb3VkMzRfNTA6IEVNQUNsb3VkKToge1xuICBpbnRyYWRheVRyZW5kOiAnYnVsbGlzaCcgfCAnYmVhcmlzaCcgfCAnbmV1dHJhbCc7XG4gIHN3aW5nVHJlbmQ6ICdidWxsaXNoJyB8ICdiZWFyaXNoJyB8ICduZXV0cmFsJztcbiAgcG9zaXRpb25UcmVuZDogJ2J1bGxpc2gnIHwgJ2JlYXJpc2gnIHwgJ25ldXRyYWwnO1xuICBzdHJlbmd0aDogbnVtYmVyO1xufSB7XG4gIGNvbnN0IGxhdGVzdDVfMTIgPSB7XG4gICAgZmFzdDogY2xvdWQ1XzEyLmZhc3RbY2xvdWQ1XzEyLmZhc3QubGVuZ3RoIC0gMV0sXG4gICAgc2xvdzogY2xvdWQ1XzEyLnNsb3dbY2xvdWQ1XzEyLnNsb3cubGVuZ3RoIC0gMV1cbiAgfTtcbiAgXG4gIGNvbnN0IGxhdGVzdDM0XzUwID0ge1xuICAgIGZhc3Q6IGNsb3VkMzRfNTAuZmFzdFtjbG91ZDM0XzUwLmZhc3QubGVuZ3RoIC0gMV0sXG4gICAgc2xvdzogY2xvdWQzNF81MC5zbG93W2Nsb3VkMzRfNTAuc2xvdy5sZW5ndGggLSAxXVxuICB9O1xuICBcbiAgLy8gR2V0IHRoZSBsYXRlc3QgcHJpY2VzIGFuZCBpbmRpY2F0b3JzXG4gIGNvbnN0IHByaWNlcyA9IGNsb3VkNV8xMi5mYXN0O1xuICBjb25zdCBsYXRlc3RQcmljZSA9IHByaWNlc1twcmljZXMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHByZXZpb3VzUHJpY2UgPSBwcmljZXNbcHJpY2VzLmxlbmd0aCAtIDJdO1xuXG4gIC8vIFByaW1hcnkgVHJlbmQgYmFzZWQgb24gMzQtNTAgem9uZVxuICBjb25zdCBhYm92ZUxvbmdUZXJtWm9uZSA9IGxhdGVzdFByaWNlID4gbGF0ZXN0MzRfNTAuc2xvdztcbiAgY29uc3QgYmVsb3dMb25nVGVybVpvbmUgPSBsYXRlc3RQcmljZSA8IGxhdGVzdDM0XzUwLnNsb3c7XG5cbiAgLy8gU2hvcnQtdGVybSBjb25maXJtYXRpb24gdXNpbmcgNS0xMiB6b25lXG4gIGNvbnN0IHNob3J0VGVybUJ1bGxpc2ggPSBsYXRlc3Q1XzEyLmZhc3QgPiBsYXRlc3Q1XzEyLnNsb3c7XG4gIGNvbnN0IHNob3J0VGVybUJlYXJpc2ggPSBsYXRlc3Q1XzEyLmZhc3QgPCBsYXRlc3Q1XzEyLnNsb3c7XG5cbiAgLy8gSW50cmFkYXkgVHJlbmRcbiAgbGV0IGludHJhZGF5VHJlbmQ6ICdidWxsaXNoJyB8ICdiZWFyaXNoJyB8ICduZXV0cmFsJyA9ICduZXV0cmFsJztcbiAgaWYgKHNob3J0VGVybUJ1bGxpc2ggJiYgbGF0ZXN0UHJpY2UgPiBwcmV2aW91c1ByaWNlKSB7XG4gICAgaW50cmFkYXlUcmVuZCA9ICdidWxsaXNoJztcbiAgfSBlbHNlIGlmIChzaG9ydFRlcm1CZWFyaXNoICYmIGxhdGVzdFByaWNlIDwgcHJldmlvdXNQcmljZSkge1xuICAgIGludHJhZGF5VHJlbmQgPSAnYmVhcmlzaCc7XG4gIH1cblxuICAvLyBTd2luZyBUcmVuZFxuICBsZXQgc3dpbmdUcmVuZDogJ2J1bGxpc2gnIHwgJ2JlYXJpc2gnIHwgJ25ldXRyYWwnID0gJ25ldXRyYWwnO1xuICBpZiAoYWJvdmVMb25nVGVybVpvbmUpIHtcbiAgICBzd2luZ1RyZW5kID0gJ2J1bGxpc2gnO1xuICB9IGVsc2UgaWYgKGJlbG93TG9uZ1Rlcm1ab25lKSB7XG4gICAgc3dpbmdUcmVuZCA9ICdiZWFyaXNoJztcbiAgfVxuXG4gIC8vIFBvc2l0aW9uIFRyZW5kIChPdmVyYWxsKVxuICBsZXQgcG9zaXRpb25UcmVuZDogJ2J1bGxpc2gnIHwgJ2JlYXJpc2gnIHwgJ25ldXRyYWwnID0gJ25ldXRyYWwnO1xuICBpZiAoYWJvdmVMb25nVGVybVpvbmUgJiYgc2hvcnRUZXJtQnVsbGlzaCkge1xuICAgIHBvc2l0aW9uVHJlbmQgPSAnYnVsbGlzaCc7XG4gIH0gZWxzZSBpZiAoYmVsb3dMb25nVGVybVpvbmUgJiYgc2hvcnRUZXJtQmVhcmlzaCkge1xuICAgIHBvc2l0aW9uVHJlbmQgPSAnYmVhcmlzaCc7XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdHJlbmQgc3RyZW5ndGggYmFzZWQgb24gZGlzdGFuY2UgZnJvbSB6b25lIGJvdW5kYXJpZXNcbiAgY29uc3Qgc2hvcnRUZXJtU3RyZW5ndGggPSBNYXRoLmFicygobGF0ZXN0UHJpY2UgLSBsYXRlc3Q1XzEyLnNsb3cpIC8gbGF0ZXN0NV8xMi5zbG93ICogMTAwKTtcbiAgY29uc3QgbG9uZ1Rlcm1TdHJlbmd0aCA9IE1hdGguYWJzKChsYXRlc3RQcmljZSAtIGxhdGVzdDM0XzUwLnNsb3cpIC8gbGF0ZXN0MzRfNTAuc2xvdyAqIDEwMCk7XG4gIFxuICBjb25zdCBzdHJlbmd0aCA9IE1hdGgubWluKDEwMCwgTWF0aC5yb3VuZCgoc2hvcnRUZXJtU3RyZW5ndGggKyBsb25nVGVybVN0cmVuZ3RoKSAqIDIpKTtcbiAgXG4gIHJldHVybiB7XG4gICAgaW50cmFkYXlUcmVuZCxcbiAgICBzd2luZ1RyZW5kLFxuICAgIHBvc2l0aW9uVHJlbmQsXG4gICAgc3RyZW5ndGhcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJjYWxjdWxhdGVEZU1hcmtQaXZvdHMiLCJwcmljZXMiLCJsZW5ndGgiLCJ4IiwicjEiLCJwcCIsInMxIiwicHJpY2UiLCJjbG9zZSIsImhpZ2giLCJsb3ciLCJvcGVuIiwiTnVtYmVyIiwidG9GaXhlZCIsImNhbGN1bGF0ZUVNQSIsInBlcmlvZCIsInNtYSIsImkiLCJrIiwiZW1hRGF0YSIsImVtYSIsInB1c2giLCJjYWxjdWxhdGVFTUFDbG91ZCIsImZhc3RQZXJpb2QiLCJzbG93UGVyaW9kIiwic29ydGVkUHJpY2VzIiwic29ydCIsImEiLCJiIiwiRGF0ZSIsImRhdGUiLCJnZXRUaW1lIiwiY2xvc2VQcmljZXMiLCJtYXAiLCJwIiwiZGF0ZXMiLCJmYXN0RU1BIiwic2xvd0VNQSIsImNyb3Nzb3ZlcnMiLCJwcmV2RmFzdCIsInByZXZTbG93IiwiY3VyckZhc3QiLCJjdXJyU2xvdyIsInR5cGUiLCJmYXN0Iiwic2xvdyIsImNhbGN1bGF0ZVRpbWVCYXNlZFBpdm90cyIsInRpbWVmcmFtZSIsInBpdm90VHlwZSIsInIzIiwicjIiLCJzMiIsInMzIiwicmVsZXZhbnRQcmljZXMiLCJzbGljZSIsInBlcmlvZEhpZ2giLCJwZXJpb2RMb3ciLCJwZXJpb2RDbG9zZSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJwZXJpb2RPcGVuIiwiZGVtYXJrUFAiLCJjYWxjdWxhdGVQaXZvdHMiLCJsZXZlbHMiLCJnZXRUcmVuZFN0YXR1cyIsImNsb3VkNV8xMiIsImNsb3VkMzRfNTAiLCJsYXRlc3Q1XzEyIiwibGF0ZXN0MzRfNTAiLCJsYXRlc3RQcmljZSIsInByZXZpb3VzUHJpY2UiLCJhYm92ZUxvbmdUZXJtWm9uZSIsImJlbG93TG9uZ1Rlcm1ab25lIiwic2hvcnRUZXJtQnVsbGlzaCIsInNob3J0VGVybUJlYXJpc2giLCJpbnRyYWRheVRyZW5kIiwic3dpbmdUcmVuZCIsInBvc2l0aW9uVHJlbmQiLCJzaG9ydFRlcm1TdHJlbmd0aCIsImFicyIsImxvbmdUZXJtU3RyZW5ndGgiLCJzdHJlbmd0aCIsInJvdW5kIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/indicators.ts\n"));

/***/ })

});